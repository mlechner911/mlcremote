// Copyright (c) 2025 MLCRemote authors
// All rights reserved. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file.

package server

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"net/http"
	"path/filepath"
	"strings"

	"lightdev/internal/handlers"
	"lightdev/internal/watcher"

	_ "lightdev/docs" // docs is generated by Swag CLI

	httpSwagger "github.com/swaggo/http-swagger"
)

// Server represents the HTTP server configuration and mux.
type Server struct {
	// Host to listen on
	Host string
	// current server root  - typically home directory
	Root string
	// static files directory (for minimal  mode, e.g., serving built frontend)
	StaticDir string
	// path to OpenAPI spec file (optional)
	OpenAPIPath string
	// AuthToken is the secret token required for access
	AuthToken string
	// Password is the optional login password
	Password string
	// AllowDelete controls if file deletion is permitted
	AllowDelete bool
	// TrashDir is the directory where deleted files are moved
	TrashDir string
	// DebugTerminal controls verbose logging for terminal sessions
	DebugTerminal bool

	// RootFallback indicates if the server fell back to default root due to invalid config
	RootFallback bool

	Mux        *http.ServeMux
	httpServer *http.Server
	// clients
	listener net.Listener
	Watcher  *watcher.Service
}

// New creates a Server with the provided root, static directory, auth token, and password.
func New(host, root, staticDir string, openapiPath string, authToken string, password string, allowDelete bool, trashDir string, debugTerminal bool) *Server {
	w, err := watcher.New(root)
	if err != nil {
		log.Printf("[ERROR] failed to create watcher: %v", err)
	}

	return &Server{
		Host:          host,
		Root:          root,
		StaticDir:     staticDir,
		OpenAPIPath:   openapiPath,
		AuthToken:     authToken,
		Password:      password,
		AllowDelete:   allowDelete,
		TrashDir:      trashDir,
		DebugTerminal: debugTerminal,
		Mux:           http.NewServeMux(),
		Watcher:       w,
	}
}

// allowCORS adds headers for Wails and other local prototyping origins
func (s *Server) allowCORS(w http.ResponseWriter, r *http.Request) {
	origin := r.Header.Get("Origin")
	if origin == "" {
		origin = "*"
	}
	// For prototype, allow all/relevant origins.
	w.Header().Set("Access-Control-Allow-Origin", origin)
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS, PUT, DELETE")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Auth-Token")
	if s.RootFallback {
		w.Header().Set("X-Root-Fallback", "true")
	}
}

// authMiddleware wraps an http.Handler and checks for the valid AuthToken.
func (s *Server) authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// TRACE LOGGING
		if !strings.Contains(r.URL.Path, "/api/logs") {
			log.Printf("[ACCESS] %s %s (Remote: %s)", r.Method, r.URL.String(), r.RemoteAddr)
		}
		s.allowCORS(w, r)

		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		// Public endpoints:
		// 1. Health check
		// 2. Login endpoint
		// 3. Version & Settings (often used for bootstrapping frontend)
		// 4. Static files (everything NOT starting with /api/ or /ws/)
		publicPaths := map[string]bool{
			"/health":       true,
			"/api/login":    true,
			"/api/settings": true,
			"/api/version":  true,
		}
		if publicPaths[r.URL.Path] {
			next.ServeHTTP(w, r)
			return
		}

		// Check if it's a static file request
		if !strings.HasPrefix(r.URL.Path, "/api/") && !strings.HasPrefix(r.URL.Path, "/ws/") {
			next.ServeHTTP(w, r)
			return
		}

		token := r.Header.Get("X-Auth-Token")
		if token == "" {
			token = r.URL.Query().Get("token")
		}

		if s.AuthToken != "" && token != s.AuthToken {
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		next.ServeHTTP(w, r)
	})
}

type loginRequest struct {
	Password string `json:"password"`
}

// @Summary Login
// @Description Exchange password for auth token.
// @ID login
// @Tags auth
// @Accept json
// @Param body body loginRequest true "Password"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 401
// @Router /api/login [post]
func (s *Server) loginHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	// if no password configured, login is disabled/irrelevant
	if s.Password == "" {
		http.Error(w, "login not configured", http.StatusForbidden)
		return
	}

	var req loginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid json", http.StatusBadRequest)
		return
	}

	// simple constant-time-ish comparison not strictly needed for this scope
	// but good habit. here we just do simple string check.
	if req.Password != s.Password {
		http.Error(w, "invalid credentials", http.StatusUnauthorized)
		return
	}

	resp := map[string]string{"token": s.AuthToken}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)

	handlers.WriteAuditLog("Login Success from %s", r.RemoteAddr)
}

// Routes registers all HTTP handlers on the server mux.
func (s *Server) Routes() {
	s.Mux.HandleFunc("/health", handlers.Health(s.Password != "", s.AuthToken != ""))

	if s.Watcher != nil {
		s.Mux.HandleFunc("/api/events", handlers.EventsHandler(s.Watcher))
	}
	// Swagger UI (inline docs)
	s.Mux.Handle("/docs/", httpSwagger.WrapHandler)

	// APIs
	s.Mux.HandleFunc("/api/login", s.loginHandler)
	s.Mux.HandleFunc("/api/auth/check", handlers.CheckAuthHandler)
	s.Mux.HandleFunc("/api/version", handlers.VersionHandler)
	s.Mux.Handle("/ws/terminal", handlers.WsTerminalHandler(s.Root, s.DebugTerminal))
	s.Mux.Handle("/api/tree", handlers.TreeHandler(s.Root))
	s.Mux.Handle("/api/filetype", handlers.FileTypeHandler(s.Root))
	// serve file sections for large-file viewing
	s.Mux.Handle("/api/file/section", handlers.FileSectionHandler(s.Root))
	s.Mux.Handle("/api/stat", handlers.StatHandler(s.Root))
	s.Mux.Handle("/api/archive/list", handlers.ListArchiveHandler(s.Root))

	settingsPath := filepath.Join(s.Root, ".mlcremote", "settings.json")
	s.Mux.Handle("/api/settings", handlers.SettingsHandler(s.AllowDelete, settingsPath))
	s.Mux.HandleFunc("/api/trash/recent", handlers.RecentTrashHandler())
	s.Mux.HandleFunc("/api/trash/restore", handlers.RestoreTrashHandler(s.Root))
	s.Mux.HandleFunc("/api/trash", handlers.EmptyTrashHandler(s.TrashDir, s.AllowDelete))
	s.Mux.Handle("/api/logs", handlers.LogsHandler()) // Register LogsHandler
	s.Mux.HandleFunc("/api/terminal/new", handlers.NewTerminalAPI(s.Root))
	s.Mux.Handle("/api/file", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			handlers.GetFileHandler(s.Root)(w, r)
		case http.MethodPost:
			handlers.PostFileHandler(s.Root)(w, r)
		case http.MethodDelete:
			handlers.DeleteFileHandler(s.Root, s.TrashDir, s.AllowDelete)(w, r)
		default:
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		}
	}))

	// Upload endpoint for drag & drop file uploads
	s.Mux.HandleFunc("/api/upload", handlers.UploadHandler(s.Root))
	s.Mux.Handle("/api/rename", handlers.RenameFileHandler(s.Root))
	s.Mux.Handle("/api/copy", handlers.CopyFileHandler(s.Root))

	// Static files (for dev)
	if s.StaticDir != "" {
		abs, err := filepath.Abs(s.StaticDir)
		if err == nil {
			fs := http.FileServer(http.Dir(abs))
			s.Mux.Handle("/", fs)
			log.Printf("serving static from %s", abs)
		}
	} else {
		s.Mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			_, _ = w.Write([]byte(`<html><head><title>Dev Server</title></head>
			<body><h1>Dev Server</h1>
			<p>Build frontend and use --static-dir to serve.</p></body></html>`))
		})
	}
}

// Start starts the HTTP server on the given port bound to localhost.

// Start starts the HTTP server on the given port bound to configured host.
func (s *Server) Start(port int) (int, error) {
	addr := fmt.Sprintf("%s:%d", s.Host, port)
	log.Printf("starting server on http://%s, root=%s", addr, s.Root)
	// create listener first so we can return binding errors synchronously
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return 0, err
	}

	// Get actual port (in case 0 was used)
	actualPort := port
	if tcpAddr, ok := ln.Addr().(*net.TCPAddr); ok {
		actualPort = tcpAddr.Port
	}

	addr = fmt.Sprintf("%s:%d", s.Host, actualPort)
	log.Printf("[INFO] server listening on http://%s", addr)
	s.listener = ln

	// Wrap mux with auth middleware
	handler := s.authMiddleware(s.Mux)

	s.httpServer = &http.Server{Addr: addr, Handler: handler}
	go func() {
		if err := s.httpServer.Serve(ln); err != nil && err != http.ErrServerClosed {
			log.Printf("server error: %v", err)
		}
	}()

	if s.Watcher != nil {
		s.Watcher.Start()
	}

	return actualPort, nil
}

// Shutdown gracefully shuts down the HTTP server and closes terminal sessions.
func (s *Server) Shutdown(ctx context.Context) error {
	// attempt to stop accepting new connections
	if s.httpServer != nil {
		if err := s.httpServer.Shutdown(ctx); err != nil {
			log.Printf("[ERROR] error closing http server: %v", err)
			// fallback to close if shutdown fails
			s.httpServer.Close()
		}
	}
	// cleanup terminal sessions
	handlers.ShutdownAllSessions()
	if s.Watcher != nil {
		s.Watcher.Stop()
	}
	return nil
}
