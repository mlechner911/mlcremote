/**
 * Generated by orval v8.0.1 üç∫
 * Do not edit manually.
 * MLCRemote API
 * Lightweight remote development server API.
 * OpenAPI spec version: 0.3.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeleteApiFileParams,
  DirEntry,
  FileStat,
  GetApiFileParams,
  GetApiFileSectionParams,
  GetApiStatParams,
  GetApiTreeParams,
  GetWsTerminalParams,
  HealthInfo,
  LoginRequest,
  LoginResponse,
  PostApiFileBody,
  PostApiTerminalNewParams,
  PostApiUploadBody,
  PostApiUploadParams,
  RestoreRequest,
  Settings,
  TerminalSession,
  TrashEntry,
  VersionInfo
} from './generated.schemas';

import { customInstance } from './axios_custom';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Public endpoint. No auth required.
 * @summary Get system health
 */
export type getHealthResponse200 = {
  data: HealthInfo
  status: 200
}
    
export type getHealthResponseSuccess = (getHealthResponse200) & {
  headers: Headers;
};
;

export type getHealthResponse = (getHealthResponseSuccess)

export const getGetHealthUrl = () => {


  

  return `/health`
}

export const getHealth = async ( options?: RequestInit): Promise<getHealthResponse> => {
  
  return customInstance<getHealthResponse>(getGetHealthUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetHealthQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getGetHealthQueryOptions = <TData = Awaited<ReturnType<typeof getHealth>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealth>>> = ({ signal }) => getHealth({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getHealth>>>
export type GetHealthQueryError = unknown


export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get system health
 */

export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Exchange password for an auth token. Public endpoint.
 * @summary Login with password
 */
export type postApiLoginResponse200 = {
  data: LoginResponse
  status: 200
}

export type postApiLoginResponse401 = {
  data: void
  status: 401
}

export type postApiLoginResponse403 = {
  data: void
  status: 403
}
    
export type postApiLoginResponseSuccess = (postApiLoginResponse200) & {
  headers: Headers;
};
export type postApiLoginResponseError = (postApiLoginResponse401 | postApiLoginResponse403) & {
  headers: Headers;
};

export type postApiLoginResponse = (postApiLoginResponseSuccess | postApiLoginResponseError)

export const getPostApiLoginUrl = () => {


  

  return `/api/login`
}

export const postApiLogin = async (loginRequest: LoginRequest, options?: RequestInit): Promise<postApiLoginResponse> => {
  
  return customInstance<postApiLoginResponse>(getPostApiLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
);}




export const getPostApiLoginMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiLogin>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiLogin>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['postApiLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiLogin>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiLogin(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postApiLogin>>>
    export type PostApiLoginMutationBody = LoginRequest
    export type PostApiLoginMutationError = void

    /**
 * @summary Login with password
 */
export const usePostApiLogin = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiLogin>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiLogin>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {
      return useMutation(getPostApiLoginMutationOptions(options), queryClient);
    }
    
/**
 * @summary Check auth token validity
 */
export type getApiAuthCheckResponse200 = {
  data: void
  status: 200
}

export type getApiAuthCheckResponse401 = {
  data: void
  status: 401
}
    
export type getApiAuthCheckResponseSuccess = (getApiAuthCheckResponse200) & {
  headers: Headers;
};
export type getApiAuthCheckResponseError = (getApiAuthCheckResponse401) & {
  headers: Headers;
};

export type getApiAuthCheckResponse = (getApiAuthCheckResponseSuccess | getApiAuthCheckResponseError)

export const getGetApiAuthCheckUrl = () => {


  

  return `/api/auth/check`
}

export const getApiAuthCheck = async ( options?: RequestInit): Promise<getApiAuthCheckResponse> => {
  
  return customInstance<getApiAuthCheckResponse>(getGetApiAuthCheckUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiAuthCheckQueryKey = () => {
    return [
    `/api/auth/check`
    ] as const;
    }

    
export const getGetApiAuthCheckQueryOptions = <TData = Awaited<ReturnType<typeof getApiAuthCheck>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiAuthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiAuthCheck>>> = ({ signal }) => getApiAuthCheck({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiAuthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiAuthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof getApiAuthCheck>>>
export type GetApiAuthCheckQueryError = void


export function useGetApiAuthCheck<TData = Awaited<ReturnType<typeof getApiAuthCheck>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAuthCheck>>,
          TError,
          Awaited<ReturnType<typeof getApiAuthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiAuthCheck<TData = Awaited<ReturnType<typeof getApiAuthCheck>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAuthCheck>>,
          TError,
          Awaited<ReturnType<typeof getApiAuthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiAuthCheck<TData = Awaited<ReturnType<typeof getApiAuthCheck>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check auth token validity
 */

export function useGetApiAuthCheck<TData = Awaited<ReturnType<typeof getApiAuthCheck>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiAuthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Public endpoint.
 * @summary Get version info
 */
export type getApiVersionResponse200 = {
  data: VersionInfo
  status: 200
}
    
export type getApiVersionResponseSuccess = (getApiVersionResponse200) & {
  headers: Headers;
};
;

export type getApiVersionResponse = (getApiVersionResponseSuccess)

export const getGetApiVersionUrl = () => {


  

  return `/api/version`
}

export const getApiVersion = async ( options?: RequestInit): Promise<getApiVersionResponse> => {
  
  return customInstance<getApiVersionResponse>(getGetApiVersionUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiVersionQueryKey = () => {
    return [
    `/api/version`
    ] as const;
    }

    
export const getGetApiVersionQueryOptions = <TData = Awaited<ReturnType<typeof getApiVersion>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiVersionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiVersion>>> = ({ signal }) => getApiVersion({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiVersion>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getApiVersion>>>
export type GetApiVersionQueryError = unknown


export function useGetApiVersion<TData = Awaited<ReturnType<typeof getApiVersion>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiVersion>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiVersion>>,
          TError,
          Awaited<ReturnType<typeof getApiVersion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiVersion<TData = Awaited<ReturnType<typeof getApiVersion>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiVersion>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiVersion>>,
          TError,
          Awaited<ReturnType<typeof getApiVersion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiVersion<TData = Awaited<ReturnType<typeof getApiVersion>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get version info
 */

export function useGetApiVersion<TData = Awaited<ReturnType<typeof getApiVersion>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiVersionQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Public endpoint.
 * @summary Get frontend settings
 */
export type getApiSettingsResponse200 = {
  data: Settings
  status: 200
}
    
export type getApiSettingsResponseSuccess = (getApiSettingsResponse200) & {
  headers: Headers;
};
;

export type getApiSettingsResponse = (getApiSettingsResponseSuccess)

export const getGetApiSettingsUrl = () => {


  

  return `/api/settings`
}

export const getApiSettings = async ( options?: RequestInit): Promise<getApiSettingsResponse> => {
  
  return customInstance<getApiSettingsResponse>(getGetApiSettingsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiSettingsQueryKey = () => {
    return [
    `/api/settings`
    ] as const;
    }

    
export const getGetApiSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getApiSettings>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSettings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiSettingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiSettings>>> = ({ signal }) => getApiSettings({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiSettings>>>
export type GetApiSettingsQueryError = unknown


export function useGetApiSettings<TData = Awaited<ReturnType<typeof getApiSettings>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSettings>>,
          TError,
          Awaited<ReturnType<typeof getApiSettings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiSettings<TData = Awaited<ReturnType<typeof getApiSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSettings>>,
          TError,
          Awaited<ReturnType<typeof getApiSettings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiSettings<TData = Awaited<ReturnType<typeof getApiSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSettings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get frontend settings
 */

export function useGetApiSettings<TData = Awaited<ReturnType<typeof getApiSettings>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSettings>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiSettingsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary List directory contents
 */
export type getApiTreeResponse200 = {
  data: DirEntry[]
  status: 200
}
    
export type getApiTreeResponseSuccess = (getApiTreeResponse200) & {
  headers: Headers;
};
;

export type getApiTreeResponse = (getApiTreeResponseSuccess)

export const getGetApiTreeUrl = (params?: GetApiTreeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/tree?${stringifiedParams}` : `/api/tree`
}

export const getApiTree = async (params?: GetApiTreeParams, options?: RequestInit): Promise<getApiTreeResponse> => {
  
  return customInstance<getApiTreeResponse>(getGetApiTreeUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiTreeQueryKey = (params?: GetApiTreeParams,) => {
    return [
    `/api/tree`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetApiTreeQueryOptions = <TData = Awaited<ReturnType<typeof getApiTree>>, TError = unknown>(params?: GetApiTreeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTree>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiTreeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiTree>>> = ({ signal }) => getApiTree(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiTree>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getApiTree>>>
export type GetApiTreeQueryError = unknown


export function useGetApiTree<TData = Awaited<ReturnType<typeof getApiTree>>, TError = unknown>(
 params: undefined |  GetApiTreeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTree>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiTree>>,
          TError,
          Awaited<ReturnType<typeof getApiTree>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiTree<TData = Awaited<ReturnType<typeof getApiTree>>, TError = unknown>(
 params?: GetApiTreeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTree>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiTree>>,
          TError,
          Awaited<ReturnType<typeof getApiTree>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiTree<TData = Awaited<ReturnType<typeof getApiTree>>, TError = unknown>(
 params?: GetApiTreeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTree>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List directory contents
 */

export function useGetApiTree<TData = Awaited<ReturnType<typeof getApiTree>>, TError = unknown>(
 params?: GetApiTreeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTree>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiTreeQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Download file content
 */
export type getApiFileResponse200 = {
  data: Blob
  status: 200
}
    
export type getApiFileResponseSuccess = (getApiFileResponse200) & {
  headers: Headers;
};
;

export type getApiFileResponse = (getApiFileResponseSuccess)

export const getGetApiFileUrl = (params: GetApiFileParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/file?${stringifiedParams}` : `/api/file`
}

export const getApiFile = async (params: GetApiFileParams, options?: RequestInit): Promise<getApiFileResponse> => {
  
  return customInstance<getApiFileResponse>(getGetApiFileUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiFileQueryKey = (params?: GetApiFileParams,) => {
    return [
    `/api/file`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetApiFileQueryOptions = <TData = Awaited<ReturnType<typeof getApiFile>>, TError = unknown>(params: GetApiFileParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiFileQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiFile>>> = ({ signal }) => getApiFile(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiFile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiFileQueryResult = NonNullable<Awaited<ReturnType<typeof getApiFile>>>
export type GetApiFileQueryError = unknown


export function useGetApiFile<TData = Awaited<ReturnType<typeof getApiFile>>, TError = unknown>(
 params: GetApiFileParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFile>>,
          TError,
          Awaited<ReturnType<typeof getApiFile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFile<TData = Awaited<ReturnType<typeof getApiFile>>, TError = unknown>(
 params: GetApiFileParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFile>>,
          TError,
          Awaited<ReturnType<typeof getApiFile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFile<TData = Awaited<ReturnType<typeof getApiFile>>, TError = unknown>(
 params: GetApiFileParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download file content
 */

export function useGetApiFile<TData = Awaited<ReturnType<typeof getApiFile>>, TError = unknown>(
 params: GetApiFileParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFile>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiFileQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create or overwrite file
 */
export type postApiFileResponse204 = {
  data: void
  status: 204
}
    
export type postApiFileResponseSuccess = (postApiFileResponse204) & {
  headers: Headers;
};
;

export type postApiFileResponse = (postApiFileResponseSuccess)

export const getPostApiFileUrl = () => {


  

  return `/api/file`
}

export const postApiFile = async (postApiFileBody: PostApiFileBody, options?: RequestInit): Promise<postApiFileResponse> => {
  
  return customInstance<postApiFileResponse>(getPostApiFileUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postApiFileBody,)
  }
);}




export const getPostApiFileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFile>>, TError,{data: PostApiFileBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiFile>>, TError,{data: PostApiFileBody}, TContext> => {

const mutationKey = ['postApiFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiFile>>, {data: PostApiFileBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiFile(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiFileMutationResult = NonNullable<Awaited<ReturnType<typeof postApiFile>>>
    export type PostApiFileMutationBody = PostApiFileBody
    export type PostApiFileMutationError = unknown

    /**
 * @summary Create or overwrite file
 */
export const usePostApiFile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFile>>, TError,{data: PostApiFileBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiFile>>,
        TError,
        {data: PostApiFileBody},
        TContext
      > => {
      return useMutation(getPostApiFileMutationOptions(options), queryClient);
    }
    
/**
 * @summary Delete file (move to trash)
 */
export type deleteApiFileResponse204 = {
  data: void
  status: 204
}

export type deleteApiFileResponse403 = {
  data: void
  status: 403
}
    
export type deleteApiFileResponseSuccess = (deleteApiFileResponse204) & {
  headers: Headers;
};
export type deleteApiFileResponseError = (deleteApiFileResponse403) & {
  headers: Headers;
};

export type deleteApiFileResponse = (deleteApiFileResponseSuccess | deleteApiFileResponseError)

export const getDeleteApiFileUrl = (params: DeleteApiFileParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/file?${stringifiedParams}` : `/api/file`
}

export const deleteApiFile = async (params: DeleteApiFileParams, options?: RequestInit): Promise<deleteApiFileResponse> => {
  
  return customInstance<deleteApiFileResponse>(getDeleteApiFileUrl(params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteApiFileMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiFile>>, TError,{params: DeleteApiFileParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiFile>>, TError,{params: DeleteApiFileParams}, TContext> => {

const mutationKey = ['deleteApiFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiFile>>, {params: DeleteApiFileParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteApiFile(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiFileMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiFile>>>
    
    export type DeleteApiFileMutationError = void

    /**
 * @summary Delete file (move to trash)
 */
export const useDeleteApiFile = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiFile>>, TError,{params: DeleteApiFileParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiFile>>,
        TError,
        {params: DeleteApiFileParams},
        TContext
      > => {
      return useMutation(getDeleteApiFileMutationOptions(options), queryClient);
    }
    
/**
 * @summary Read file section
 */
export type getApiFileSectionResponse200 = {
  data: void
  status: 200
}
    
export type getApiFileSectionResponseSuccess = (getApiFileSectionResponse200) & {
  headers: Headers;
};
;

export type getApiFileSectionResponse = (getApiFileSectionResponseSuccess)

export const getGetApiFileSectionUrl = (params: GetApiFileSectionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/file/section?${stringifiedParams}` : `/api/file/section`
}

export const getApiFileSection = async (params: GetApiFileSectionParams, options?: RequestInit): Promise<getApiFileSectionResponse> => {
  
  return customInstance<getApiFileSectionResponse>(getGetApiFileSectionUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiFileSectionQueryKey = (params?: GetApiFileSectionParams,) => {
    return [
    `/api/file/section`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetApiFileSectionQueryOptions = <TData = Awaited<ReturnType<typeof getApiFileSection>>, TError = unknown>(params: GetApiFileSectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFileSection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiFileSectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiFileSection>>> = ({ signal }) => getApiFileSection(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiFileSection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiFileSectionQueryResult = NonNullable<Awaited<ReturnType<typeof getApiFileSection>>>
export type GetApiFileSectionQueryError = unknown


export function useGetApiFileSection<TData = Awaited<ReturnType<typeof getApiFileSection>>, TError = unknown>(
 params: GetApiFileSectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFileSection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFileSection>>,
          TError,
          Awaited<ReturnType<typeof getApiFileSection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFileSection<TData = Awaited<ReturnType<typeof getApiFileSection>>, TError = unknown>(
 params: GetApiFileSectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFileSection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFileSection>>,
          TError,
          Awaited<ReturnType<typeof getApiFileSection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFileSection<TData = Awaited<ReturnType<typeof getApiFileSection>>, TError = unknown>(
 params: GetApiFileSectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFileSection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read file section
 */

export function useGetApiFileSection<TData = Awaited<ReturnType<typeof getApiFileSection>>, TError = unknown>(
 params: GetApiFileSectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFileSection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiFileSectionQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get file metadata
 */
export type getApiStatResponse200 = {
  data: FileStat
  status: 200
}
    
export type getApiStatResponseSuccess = (getApiStatResponse200) & {
  headers: Headers;
};
;

export type getApiStatResponse = (getApiStatResponseSuccess)

export const getGetApiStatUrl = (params: GetApiStatParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/stat?${stringifiedParams}` : `/api/stat`
}

export const getApiStat = async (params: GetApiStatParams, options?: RequestInit): Promise<getApiStatResponse> => {
  
  return customInstance<getApiStatResponse>(getGetApiStatUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiStatQueryKey = (params?: GetApiStatParams,) => {
    return [
    `/api/stat`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetApiStatQueryOptions = <TData = Awaited<ReturnType<typeof getApiStat>>, TError = unknown>(params: GetApiStatParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiStat>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiStatQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiStat>>> = ({ signal }) => getApiStat(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiStat>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiStatQueryResult = NonNullable<Awaited<ReturnType<typeof getApiStat>>>
export type GetApiStatQueryError = unknown


export function useGetApiStat<TData = Awaited<ReturnType<typeof getApiStat>>, TError = unknown>(
 params: GetApiStatParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiStat>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiStat>>,
          TError,
          Awaited<ReturnType<typeof getApiStat>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiStat<TData = Awaited<ReturnType<typeof getApiStat>>, TError = unknown>(
 params: GetApiStatParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiStat>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiStat>>,
          TError,
          Awaited<ReturnType<typeof getApiStat>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiStat<TData = Awaited<ReturnType<typeof getApiStat>>, TError = unknown>(
 params: GetApiStatParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiStat>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get file metadata
 */

export function useGetApiStat<TData = Awaited<ReturnType<typeof getApiStat>>, TError = unknown>(
 params: GetApiStatParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiStat>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiStatQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Upload files
 */
export type postApiUploadResponse204 = {
  data: void
  status: 204
}
    
export type postApiUploadResponseSuccess = (postApiUploadResponse204) & {
  headers: Headers;
};
;

export type postApiUploadResponse = (postApiUploadResponseSuccess)

export const getPostApiUploadUrl = (params?: PostApiUploadParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/upload?${stringifiedParams}` : `/api/upload`
}

export const postApiUpload = async (postApiUploadBody: PostApiUploadBody,
    params?: PostApiUploadParams, options?: RequestInit): Promise<postApiUploadResponse> => {
    const formData = new FormData();
if(postApiUploadBody.file !== undefined) {
 postApiUploadBody.file.forEach(value => formData.append(`file`, value));
 }

  return customInstance<postApiUploadResponse>(getPostApiUploadUrl(params),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPostApiUploadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiUpload>>, TError,{data: PostApiUploadBody;params?: PostApiUploadParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiUpload>>, TError,{data: PostApiUploadBody;params?: PostApiUploadParams}, TContext> => {

const mutationKey = ['postApiUpload'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiUpload>>, {data: PostApiUploadBody;params?: PostApiUploadParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postApiUpload(data,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiUploadMutationResult = NonNullable<Awaited<ReturnType<typeof postApiUpload>>>
    export type PostApiUploadMutationBody = PostApiUploadBody
    export type PostApiUploadMutationError = unknown

    /**
 * @summary Upload files
 */
export const usePostApiUpload = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiUpload>>, TError,{data: PostApiUploadBody;params?: PostApiUploadParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiUpload>>,
        TError,
        {data: PostApiUploadBody;params?: PostApiUploadParams},
        TContext
      > => {
      return useMutation(getPostApiUploadMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get recently deleted files
 */
export type getApiTrashRecentResponse200 = {
  data: TrashEntry[]
  status: 200
}
    
export type getApiTrashRecentResponseSuccess = (getApiTrashRecentResponse200) & {
  headers: Headers;
};
;

export type getApiTrashRecentResponse = (getApiTrashRecentResponseSuccess)

export const getGetApiTrashRecentUrl = () => {


  

  return `/api/trash/recent`
}

export const getApiTrashRecent = async ( options?: RequestInit): Promise<getApiTrashRecentResponse> => {
  
  return customInstance<getApiTrashRecentResponse>(getGetApiTrashRecentUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiTrashRecentQueryKey = () => {
    return [
    `/api/trash/recent`
    ] as const;
    }

    
export const getGetApiTrashRecentQueryOptions = <TData = Awaited<ReturnType<typeof getApiTrashRecent>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTrashRecent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiTrashRecentQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiTrashRecent>>> = ({ signal }) => getApiTrashRecent({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiTrashRecent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiTrashRecentQueryResult = NonNullable<Awaited<ReturnType<typeof getApiTrashRecent>>>
export type GetApiTrashRecentQueryError = unknown


export function useGetApiTrashRecent<TData = Awaited<ReturnType<typeof getApiTrashRecent>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTrashRecent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiTrashRecent>>,
          TError,
          Awaited<ReturnType<typeof getApiTrashRecent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiTrashRecent<TData = Awaited<ReturnType<typeof getApiTrashRecent>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTrashRecent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiTrashRecent>>,
          TError,
          Awaited<ReturnType<typeof getApiTrashRecent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiTrashRecent<TData = Awaited<ReturnType<typeof getApiTrashRecent>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTrashRecent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get recently deleted files
 */

export function useGetApiTrashRecent<TData = Awaited<ReturnType<typeof getApiTrashRecent>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiTrashRecent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiTrashRecentQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Restore file from trash
 */
export type postApiTrashRestoreResponse204 = {
  data: void
  status: 204
}

export type postApiTrashRestoreResponse404 = {
  data: void
  status: 404
}

export type postApiTrashRestoreResponse409 = {
  data: void
  status: 409
}
    
export type postApiTrashRestoreResponseSuccess = (postApiTrashRestoreResponse204) & {
  headers: Headers;
};
export type postApiTrashRestoreResponseError = (postApiTrashRestoreResponse404 | postApiTrashRestoreResponse409) & {
  headers: Headers;
};

export type postApiTrashRestoreResponse = (postApiTrashRestoreResponseSuccess | postApiTrashRestoreResponseError)

export const getPostApiTrashRestoreUrl = () => {


  

  return `/api/trash/restore`
}

export const postApiTrashRestore = async (restoreRequest: RestoreRequest, options?: RequestInit): Promise<postApiTrashRestoreResponse> => {
  
  return customInstance<postApiTrashRestoreResponse>(getPostApiTrashRestoreUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      restoreRequest,)
  }
);}




export const getPostApiTrashRestoreMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiTrashRestore>>, TError,{data: RestoreRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiTrashRestore>>, TError,{data: RestoreRequest}, TContext> => {

const mutationKey = ['postApiTrashRestore'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiTrashRestore>>, {data: RestoreRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiTrashRestore(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiTrashRestoreMutationResult = NonNullable<Awaited<ReturnType<typeof postApiTrashRestore>>>
    export type PostApiTrashRestoreMutationBody = RestoreRequest
    export type PostApiTrashRestoreMutationError = void

    /**
 * @summary Restore file from trash
 */
export const usePostApiTrashRestore = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiTrashRestore>>, TError,{data: RestoreRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiTrashRestore>>,
        TError,
        {data: RestoreRequest},
        TContext
      > => {
      return useMutation(getPostApiTrashRestoreMutationOptions(options), queryClient);
    }
    
/**
 * Permanently delete all files in trash. Requires allow_delete=true.
 * @summary Empty trash
 */
export type deleteApiTrashResponse204 = {
  data: void
  status: 204
}
    
export type deleteApiTrashResponseSuccess = (deleteApiTrashResponse204) & {
  headers: Headers;
};
;

export type deleteApiTrashResponse = (deleteApiTrashResponseSuccess)

export const getDeleteApiTrashUrl = () => {


  

  return `/api/trash`
}

export const deleteApiTrash = async ( options?: RequestInit): Promise<deleteApiTrashResponse> => {
  
  return customInstance<deleteApiTrashResponse>(getDeleteApiTrashUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteApiTrashMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiTrash>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiTrash>>, TError,void, TContext> => {

const mutationKey = ['deleteApiTrash'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiTrash>>, void> = () => {
          

          return  deleteApiTrash(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiTrashMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiTrash>>>
    
    export type DeleteApiTrashMutationError = unknown

    /**
 * @summary Empty trash
 */
export const useDeleteApiTrash = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiTrash>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiTrash>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getDeleteApiTrashMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create terminal session
 */
export type postApiTerminalNewResponse200 = {
  data: TerminalSession
  status: 200
}
    
export type postApiTerminalNewResponseSuccess = (postApiTerminalNewResponse200) & {
  headers: Headers;
};
;

export type postApiTerminalNewResponse = (postApiTerminalNewResponseSuccess)

export const getPostApiTerminalNewUrl = (params?: PostApiTerminalNewParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/terminal/new?${stringifiedParams}` : `/api/terminal/new`
}

export const postApiTerminalNew = async (params?: PostApiTerminalNewParams, options?: RequestInit): Promise<postApiTerminalNewResponse> => {
  
  return customInstance<postApiTerminalNewResponse>(getPostApiTerminalNewUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getPostApiTerminalNewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiTerminalNew>>, TError,{params?: PostApiTerminalNewParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiTerminalNew>>, TError,{params?: PostApiTerminalNewParams}, TContext> => {

const mutationKey = ['postApiTerminalNew'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiTerminalNew>>, {params?: PostApiTerminalNewParams}> = (props) => {
          const {params} = props ?? {};

          return  postApiTerminalNew(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiTerminalNewMutationResult = NonNullable<Awaited<ReturnType<typeof postApiTerminalNew>>>
    
    export type PostApiTerminalNewMutationError = unknown

    /**
 * @summary Create terminal session
 */
export const usePostApiTerminalNew = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiTerminalNew>>, TError,{params?: PostApiTerminalNewParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiTerminalNew>>,
        TError,
        {params?: PostApiTerminalNewParams},
        TContext
      > => {
      return useMutation(getPostApiTerminalNewMutationOptions(options), queryClient);
    }
    
/**
 * Upgrade request to WebSocket.
 * @summary Connect to terminal WebSocket
 */
export type getWsTerminalResponse101 = {
  data: void
  status: 101
}
    
;
export type getWsTerminalResponseError = (getWsTerminalResponse101) & {
  headers: Headers;
};

export type getWsTerminalResponse = (getWsTerminalResponseError)

export const getGetWsTerminalUrl = (params?: GetWsTerminalParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/ws/terminal?${stringifiedParams}` : `/ws/terminal`
}

export const getWsTerminal = async (params?: GetWsTerminalParams, options?: RequestInit): Promise<getWsTerminalResponse> => {
  
  return customInstance<getWsTerminalResponse>(getGetWsTerminalUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetWsTerminalQueryKey = (params?: GetWsTerminalParams,) => {
    return [
    `/ws/terminal`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetWsTerminalQueryOptions = <TData = Awaited<ReturnType<typeof getWsTerminal>>, TError = void>(params?: GetWsTerminalParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWsTerminal>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWsTerminalQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWsTerminal>>> = ({ signal }) => getWsTerminal(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWsTerminal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWsTerminalQueryResult = NonNullable<Awaited<ReturnType<typeof getWsTerminal>>>
export type GetWsTerminalQueryError = void


export function useGetWsTerminal<TData = Awaited<ReturnType<typeof getWsTerminal>>, TError = void>(
 params: undefined |  GetWsTerminalParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWsTerminal>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWsTerminal>>,
          TError,
          Awaited<ReturnType<typeof getWsTerminal>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWsTerminal<TData = Awaited<ReturnType<typeof getWsTerminal>>, TError = void>(
 params?: GetWsTerminalParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWsTerminal>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWsTerminal>>,
          TError,
          Awaited<ReturnType<typeof getWsTerminal>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWsTerminal<TData = Awaited<ReturnType<typeof getWsTerminal>>, TError = void>(
 params?: GetWsTerminalParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWsTerminal>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Connect to terminal WebSocket
 */

export function useGetWsTerminal<TData = Awaited<ReturnType<typeof getWsTerminal>>, TError = void>(
 params?: GetWsTerminalParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWsTerminal>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWsTerminalQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





